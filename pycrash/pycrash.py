# PyCrash - A crash handler for the Python programming language

# (C)Copyright Carmine Ivan Delio Noviello 2003 <cnoviello@programmers.net>

# For further informations, please refer to: pycrash.sourceforge.net

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

import types, sys, os, string, atexit, time, threading
from exctb import ExceptionTraceBack

_DictType = types.DictType
_StringType = types.StringType
del types

_exc_info = sys.exc_info

try:
	_uname	= os.uname
except:
	_uname = lambda:"(undefined)"
del os

_StringLower = string.lower
del string

_atexit_register = atexit.register
del atexit

_time = time.time
_localtime = time.localtime
del time

_currentThread = threading.currentThread
del threading

#Global variables definition
PYCRASH_VERSION 	= "0.2"
PYCRASH_STRINGS_INFO 	= ['AppName', "Version", "SendTo"]
PYCRASH_REFERENCE 	= None


class PyCrash:

	__initialized = 0 #initialization flag
	
	def __init__(self, strings):
		assert type(strings) is _DictType, "'strings' must be a dictionary"
	
		global PYCRASH_REFERENCE, PYCRASH_VERSION, PYCRASH_STRINGS_INFO
			
		#A PyCrash object must be static (unique for the entiere application).
		#So we first check that this is the first istance
		if PYCRASH_REFERENCE is not None:
			return PYCRASH_REFERENCE
		#Then we check that if this object is just initialized
		if self.__initialized:
			return 
		
		self.__appCrashed = 0
		self.__tbList = [] #List of ExceptionThraceback objects
		self.__time = [str(_localtime(_time())), None] #[0]=application started, [1]=application crashed
		self.__customRecords = []

		#Hooks need for catch raised exception and application exit
		sys.excepthook = self.__exceptHook
		_atexit_register(self.__exit)
		
		for attr in PYCRASH_STRINGS_INFO: #Adding additional info
			try:
				setattr(self, "_" + attr, strings[attr])
			except KeyError, key:
				setattr(self, "_" + attr, '(undef)')

		self.__initialized = 1 #The PyCrash object is now intialized

		#We set this variable in order to have an unique PyCrash object
		#for the application
		PYCRASH_REFERENCE = self
	
	def __exceptHook(self, type, value, tb):
		#Ok. Something is wrong and let's build the crush dump
		
		#This method is called each time an exception isn't caught. So
		#we must check that this is the first time
		if not self.__appCrashed:
			self.__appCrashed = 1
			self.__time[1] = str(_localtime(_time()))
		
		#We fetch the reference to current thread to take its name
		t = _currentThread()
		self.__mkCrashDump(t.getName(), (type, value, tb))

	def __exit(self): 
		try:
			self.onExit()	
		except Exception, msg:
			print Exception, msg

	def __mkCrashDump(self, thread, excInfo):
		#This is the routine which builds up the crash dump 
		assert self.__initialized, "PyCrash.__init__() not called"
		
		#Parsing each exception traceback
		self.__tbList.append(ExceptionTraceBack(thread, excInfo))

	def addCustomRecord(self, record):		
		assert self.__initialized, "PyCrash.__init__() not called"
		self.__customRecords.append(record)
	
	def printErrorMessage(self, exception, message):
		#TODO: this function should print something of more useful
		print exception, message
	
	def getInfoText(self):
		assert self.__initialized, "PyCrash.__init__() not called"
		
		strInfo = """
This file is automatically generated by PyCrash, a crash 
handler for Python written applications. This crash file refers
to """ + self._AppName + " program, Version " + self._Version + """.
Please send it to """ + self._SendTo

		return strInfo
	
	def getCrashDump(self):
		if self.__appCrashed:
			return self.toXML()

	def getFileName(self):
		try:
			return self.__fileName
		except:
			return None

	def isCrashed(self):
		""" Returns 1 (true) if the application has been crashed, 
		    otherwise 0 """
		assert self.__initialized, "PyCrash.__init__() not called"
		
		return self.__appCrashed
	
	def onBegin(self):
		""" User's defined actions: derived classes can override this
		    method to add custom actions. This method is called at the 
		    begin of crash dump construction """
		pass #User-defined actions

	def onEnd(self):
		""" User's defined actions: derived classes can override this
		    method to add custom actions. This method is called at the end
		    of crash dump construction """
		pass #User-defined actions
	
	def onExit(self):
		""" User's defined actions: derived classes can override this
		    method to add custom actions. This method is called at the exit 
		    of application """
		pass #User-defined actions
	
	def saveToFile(self, filename):
		""" Save the crash dump file in a given 'filename' directory """
		
		self.__fileName = filename
		
		if self.__appCrashed:
			assert self.__initialized, "PyCrash.__init__() not called"
			assert self.__appCrashed, "The application is not crashed"
		
			fd = open(filename, "w")
			fd.write(self.getCrashDump())
			fd.close()

	def __getAppInfo(self):
		strInfo = " appname=\"" + self._AppName + "\" appversion=\"" +  self._Version + "\"" 
		strInfo += " started=\"" + self.__time[0] + "\" crashed=\"" + self.__time[1] + "\""
		return strInfo

	def __getCustomRecords(self):
		strInfo = ""
		for elem in self.__customRecords:
			strInfo += "\t<customrecord>" + elem + "</customrecord>\n"

		return strInfo

	def __getOSInfo(self):
		strInfo = " osinfo=\"" + str(_uname()) + "\""
		return strInfo
	
	def __getPythonInfo(self):
		strInfo = " pyversion=\"" + str(sys.version_info) + "\""
		strInfo += " pyapiversion=\"" + str(sys.api_version) + "\""
		return strInfo
		
	def toXML(self):
		""" Returns the XML rapresentation of the crash dump """
		assert self.__initialized, "PyCrash.__init__() not called"
		
		strXML = "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n"
		strXML += "<!--" + self.getInfoText() + " -->\n"
		strXML += "<PyCrash version=\"" + PYCRASH_VERSION + "\""
		strXML += self.__getAppInfo() 
		strXML += self.__getOSInfo()  
		strXML += self.__getPythonInfo() + ">\n"
		strXML += self.__getCustomRecords()

		for tb in self.__tbList:
			strXML += tb.toXML()
		strXML += "</PyCrash>\n"

		return strXML
